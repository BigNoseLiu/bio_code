#!/usr/bin/perl
#!/bin/bash
use warnings;
use strict;
use Getopt::Long;
use Term::ANSIColor;
use FindBin qw($Bin $Script);
use File::Basename qw(basename dirname);
use File::Path qw(rmtree);
use Cwd qw(abs_path);
use Data::Dumper;

sub usageWithColor {
	print color "green";#change the text color
	print <<USAGE;
Description:
        Used to 1. tag nearby(10bp) & overlap variant. 2. fix asterisk in vcf4.2 for vcf generated by gatk4
Usage:  
        perl $0 [options] -in gatk.filter.vcf -ref hg19.fa -out gatk.filter.fix.vcf
        Options:
	     -help : reveal help info
        Example:
        	perl $0 -in gatk.filter.vcf -ref hg19.fa -out gatk.filter.fix.vcf
Author & Contact:
	Mingming Liu
Last updated:
        2019-1-14
USAGE
	print color "reset";#change back the text color
}
sub err_print{
	print STDERR color "red";#change the text color
	print STDERR $_[0];
	print STDERR color "reset";#change back the text color
}

my ($help,$input_file,$ref_fa_file,$outfile);
GetOptions(
	"help"=>\$help,
	"in=s"=>\$input_file,
	"out=s"=>\$outfile,
	"ref=s"=>\$ref_fa_file,
);
if (defined $help ) {
	&usageWithColor();
	exit 0;
}

my $line;

#get ref fa
open REF,$ref_fa_file or die $!;
$/ = ">";
my %h_ref_fa = ();
while( $line = <REF> ){
	if( $line =~ /^(\S+)\s/ ){
		my $chr = $1;
		$line =~ s/^[^\n]*\n//;
		$line =~ s/\s//g;
		$h_ref_fa{$chr} = $line;
	}
}
$/ = "\n";
close REF;

my $flag_inter = 0;
my $min_dis = 10;
my @last_arr = ("-",0);
my $last_pos = 0;
while( $line = <STDIN> ){
	chomp $line;

	#vcf headers
	if( $line =~ /^#/ ){
		if( $flag_inter == 0 && $line =~ /^##FILTER/  ){
			$flag_inter = 1;
			print '##FILTER=<ID=NearbyVariant,Description="close to other variant(<10bp)">'."\n";
			print '##FILTER=<ID=OverlapVariant,Description="overlap with other variant">'."\n";
		}
		elsif( $line =~ /^#CHROM/  ){
			print "##fix_cmd=cat input.vcf|perl $0 -ref $ref_fa_file >output.vcf\n";
		}
		print $line."\n";
		next;
	}
	$line =~ s/^chr//i;
	my @arr = split(/\t/,$line);
	if( $arr[0] eq $last_arr[0] && ($arr[1] - $last_pos) < $min_dis ){
		#tag nearby variant
		$arr[6] .= ";NearbyVariant";
		$arr[6] =~ s/^\.;//;
		if( $last_arr[6] !~ /NearbyVariant/ ){
			$last_arr[6] .= ";NearbyVariant";
			$last_arr[6] =~ s/^\.;//;
		}
	}
	if( $arr[0] eq $last_arr[0] && $arr[1] <= $last_pos ){
		#tag Overlap variant
		$arr[6] .= ";OverlapVariant";
		$arr[6] =~ s/^\.;//;
		if( $last_arr[6] !~ /OverlapVariant/ ){
			$last_arr[6] .= ";OverlapVariant";
			$last_arr[6] =~ s/^\.;//;
		}
	}
	my $current_pos = $arr[1] + length($arr[3]) - 1;
	if( $arr[0] eq $last_arr[0] && $current_pos < $last_pos ){
	}
	else{
		$last_pos = $current_pos;
	}
	print join("\t",@last_arr)."\n" if( $last_arr[0] ne "-" );

	#fix asterisk in vcf 4.2
	if( $arr[4] =~ /\*/ ){
		$arr[1] = $arr[1]-1;
		my $add_base = substr($h_ref_fa{$arr[0]},$arr[1]-1,1);
		$arr[3] = $add_base.$arr[3];
		my @alts = split(",",$arr[4]);
		for(my $i=0;$i<scalar@alts;$i++){
			if( $alts[$i] eq '*' ){
				$alts[$i] = $add_base;
			}
			else{
				$alts[$i] = $add_base.$alts[$i];
			}
		}
		$arr[4] = join(",",@alts);
		
	}
	@last_arr = @arr;
}
print join("\t",@last_arr)."\n";
